#!/usr/bin/env python3

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import Pose, PoseStamped
from math import pi
from std_msgs.msg import String, Bool, Int16
from moveit_commander.conversions import pose_to_list
from std_srvs.srv import Empty, EmptyResponse, SetBool, SetBoolResponse
from moveit_commander.conversions import pose_to_list
from moveit_msgs.msg import MoveItErrorCodes
from arm_motion.srv import Step

class MoveGroupPythonInterface(object):
    def __init__(self):
        super(MoveGroupPythonInterface, self).__init__()
        rospy.loginfo('RUNNING INIT')
        rospy.init_node('record_waypoints', anonymous=True)
        joint_state_topic = ['joint_states:=/robot/joint_states']
        ## First initialize `moveit_commander`_ and a `rospy`_ node:
        moveit_commander.roscpp_initialize(joint_state_topic)
        
        robot = moveit_commander.RobotCommander(robot_description='/robot_description')

        scene = moveit_commander.PlanningSceneInterface()

        group_name = "right_arm"
        self.group = moveit_commander.MoveGroupCommander(robot_description='/robot_description', name=group_name)
        #self.group.set_planner_id('LBKPIECE')
        display_trajectory_publisher = rospy.Publisher("move_group/display_planned_path",
                                                        moveit_msgs.msg.DisplayTrajectory,
                                                        queue_size=20)

        self.initial_pose = self.group.get_current_pose().pose

        self.turtle_sub = rospy.Subscriber('/next', String, self.arm_action_callback)
        
        ## store three target positions into waypoints
        self.scan_x = rospy.get_param('/waypoints/x')
        self.scan_y = rospy.get_param('/waypoints/y')
        self.scan_z = rospy.get_param('/waypoints/z')
        self.scan_x_o = rospy.get_param('/waypoints/x_o')
        self.scan_y_o = rospy.get_param('/waypoints/y_o')
        self.scan_z_o = rospy.get_param('/waypoints/z_o')
        self.scan_w_o = rospy.get_param('/waypoints/w_o')
        ## set home pose 
        self.home = Pose()
        self.home.position.x = self.scan_x[0]
        self.home.position.y = self.scan_y[0]
        self.home.position.z = self.scan_z[0]
        self.home.orientation.x = self.scan_x_o[0]
        self.home.orientation.y = self.scan_y_o[0]
        self.home.orientation.z = self.scan_z_o[0]
        self.home.orientation.w = self.scan_w_o[0]
        rospy.loginfo('saved home pose')

        # self.group.set_named_target("Home")
        self.group.set_pose_target(self.home)
        success, traj, p_time, errorcode = self.group.plan()
        # self.group.go()
        self.group.execute(traj, wait=True)
        self.group.stop()                                  
        self.group.clear_pose_targets()
        rospy.loginfo('moved to home')

    #     # store all past states
        self.x_list = []
        self.y_list = []
        self.z_list = []
        self.x_o_list = []
        self.y_o_list = []
        self.z_o_list = []
        self.w_o_list = []

        self.x_sent_list = []
        self.y_sent_list = []
        self.z_sent_list = []
        self.x_sent_o_list = []
        self.y_sent_o_list = []
        self.z_sent_o_list = []
        self.w_sent_o_list = []

        self.reset = rospy.Service("reset", Empty, self.reset_callback)
        self.step = rospy.Service("step", Step, self.step_callback)
        self.follow = rospy.Service("follow", Empty, self.follow_callback)

        # self.arm_action = rospy.Subscriber('/next', Bool, self.arm_action_callback)
        self.turtle_go = rospy.Publisher('/next', String, queue_size=10)

    def reset_callback(self, req):
        """ reset service callback
            returns the robot to the defined home position

            args:
                none

            returns:
                EmptyResponse
        """
        self.group.set_pose_target(self.home)
        success, traj, p_time, errorcode = self.group.plan()
        self.group.execute(traj, wait=True)
        self.group.stop()                                  
        self.group.clear_pose_targets()
        return EmptyResponse()

    def arm_action_callback(self, req):
        rospy.loginfo(req)
        if req == String("sawyer"):
            for i in range(len(self.scan_x)):
                p = Pose()
                p.orientation.x = self.scan_x_o[i]
                p.orientation.y = self.scan_y_o[i]
                p.orientation.z = self.scan_z_o[i]
                p.orientation.w = self.scan_w_o[i]
                p.position.x = self.scan_x[i]
                p.position.y = self.scan_y[i]
                p.position.z = self.scan_z[i]

                self.group.set_pose_target(p)
                success, traj, p_time, errorcode = self.group.plan()
                self.group.execute(traj, wait=True)
                self.group.stop()                                  
                self.group.clear_pose_targets()

            self.turtle_go.publish(String("turtle"))

    def step_callback(self, req):
        """ step service callback
            reads in a user input pose and gripper boolean
            plans a motion path and executes it
            saves the user input points to a waypoints list if planning successful

            args:
                Pose
                bool

            returns:
                MoveitErrorCodes
        """
        current_pose = self.group.get_current_pose().pose
        
        self.x_list.append(current_pose.position.x)
        self.y_list.append(current_pose.position.y)
        self.z_list.append(current_pose.position.z)
        self.x_o_list.append(current_pose.orientation.x)
        self.y_o_list.append(current_pose.orientation.y)
        self.z_o_list.append(current_pose.orientation.z)
        self.w_o_list.append(current_pose.orientation.w)

        rospy.set_param('/waypoints/x', self.x_list)
        rospy.set_param('/waypoints/y', self.y_list)
        rospy.set_param('/waypoints/z', self.z_list)
        rospy.set_param('/waypoints/x_o', self.x_o_list)
        rospy.set_param('/waypoints/y_o', self.y_o_list)
        rospy.set_param('/waypoints/z_o', self.z_o_list)
        rospy.set_param('/waypoints/w_o', self.w_o_list)

        return MoveItErrorCodes()

    def follow_callback(self, req):
        """ follow service callback
            executes the path of previously saved waypoints

            returns:
                EmptyResponse
        """
        for i in range(len(self.x_list)):
            p = Pose()
            p.orientation.x = self.x_o_list[i]
            p.orientation.y = self.y_o_list[i]
            p.orientation.z = self.z_o_list[i]
            p.orientation.w = self.w_o_list[i]
            p.position.x = self.x_list[i]
            p.position.y = self.y_list[i]
            p.position.z = self.z_list[i]

            self.group.set_pose_target(p)
            success, traj, p_time, errorcode = self.group.plan()
            self.group.execute(traj, wait=True)
            self.group.stop()                                   # Calling ``stop()`` ensures that there is no residual movement
            self.group.clear_pose_targets()

        return EmptyResponse()


def main():
    rospy.loginfo('---------------')
    moveit_commander.roscpp_initialize(sys.argv)
    mover = MoveGroupPythonInterface()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
